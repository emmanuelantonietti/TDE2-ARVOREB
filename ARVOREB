import javax.swing.*;
import java.awt.*;

class ArvoreB {
    private NoB raiz;
    private int grauMinimo;
    private int chaveBuscada = -1;

    public ArvoreB(int t) {
        this.grauMinimo = t;
        this.raiz = new NoB(t, true);
    }

    class NoB {
        int grauMinimo;
        int chaves[];
        NoB filhos[];
        int numChaves;
        boolean folha;

        public NoB(int t, boolean folha) {
            this.grauMinimo = t;
            this.folha = folha;
            this.chaves = new int[2 * t - 1];
            this.filhos = new NoB[2 * t];
            this.numChaves = 0;
        }

        public int buscar(int k) {
            int i = 0;
            while (i < numChaves && chaves[i] < k) i++;
            if (i < numChaves && chaves[i] == k) return chaves[i];
            if (folha) return -1;
            return filhos[i].buscar(k);
        }
    }

    // INSERÇÃO
    public void inserir(int k) {
        NoB r = raiz;
        if (r.numChaves == 2 * grauMinimo - 1) {
            NoB s = new NoB(grauMinimo, false);
            s.filhos[0] = r;
            splitFilho(s, 0, r);
            int i = (s.chaves[0] < k) ? 1 : 0;
            inserirNaoCheio(s.filhos[i], k);
            raiz = s;
        } else {
            inserirNaoCheio(r, k);
        }
    }

    private void inserirNaoCheio(NoB x, int k) {
        int i = x.numChaves - 1;
        if (x.folha) {
            while (i >= 0 && x.chaves[i] > k) {
                x.chaves[i + 1] = x.chaves[i];
                i--;
            }
            x.chaves[i + 1] = k;
            x.numChaves++;
        } else {
            while (i >= 0 && x.chaves[i] > k) i--;
            i++;
            if (x.filhos[i].numChaves == 2 * grauMinimo - 1) {
                splitFilho(x, i, x.filhos[i]);
                if (x.chaves[i] < k) i++;
            }
            inserirNaoCheio(x.filhos[i], k);
        }
    }

    private void splitFilho(NoB pai, int i, NoB y) {
        NoB z = new NoB(y.grauMinimo, y.folha);
        z.numChaves = grauMinimo - 1;

        for (int j = 0; j < grauMinimo - 1; j++)
            z.chaves[j] = y.chaves[j + grauMinimo];

        if (!y.folha) {
            for (int j = 0; j < grauMinimo; j++)
                z.filhos[j] = y.filhos[j + grauMinimo];
        }

        y.numChaves = grauMinimo - 1;

        for (int j = pai.numChaves; j >= i + 1; j--)
            pai.filhos[j + 1] = pai.filhos[j];
        pai.filhos[i + 1] = z;

        for (int j = pai.numChaves - 1; j >= i; j--)
            pai.chaves[j + 1] = pai.chaves[j];
        pai.chaves[i] = y.chaves[grauMinimo - 1];

        pai.numChaves++;
    }

    //  REMOÇÃO
    public void remover(int k) {
        if (buscar(k) == -1) return;
        removerDaArvore(raiz, k);
        if (raiz.numChaves == 0) {
            if (raiz.folha) raiz = null;
            else raiz = raiz.filhos[0];
        }
    }

    private void removerDaArvore(NoB no, int k) {
        int i = 0;
        while (i < no.numChaves && no.chaves[i] < k) i++;

        if (i < no.numChaves && no.chaves[i] == k) {
            if (no.folha) {
                for (int j = i + 1; j < no.numChaves; j++) no.chaves[j - 1] = no.chaves[j];
                no.numChaves--;
            } else {
                NoB pred = no.filhos[i];
                if (pred.numChaves >= grauMinimo) {
                    int predecessor = getPredecessor(no, i);
                    no.chaves[i] = predecessor;
                    removerDaArvore(pred, predecessor);
                } else {
                    NoB succ = no.filhos[i + 1];
                    if (succ.numChaves >= grauMinimo) {
                        int sucessor = getSucessor(no, i);
                        no.chaves[i] = sucessor;
                        removerDaArvore(succ, sucessor);
                    } else {
                        fundir(no, i);
                        removerDaArvore(pred, k);
                    }
                }
            }
        } else {
            if (!no.folha) removerDaArvore(no.filhos[i], k);
        }
    }

    private int getPredecessor(NoB no, int indice) {
        NoB atual = no.filhos[indice];
        while (!atual.folha) atual = atual.filhos[atual.numChaves];
        return atual.chaves[atual.numChaves - 1];
    }

    private int getSucessor(NoB no, int indice) {
        NoB atual = no.filhos[indice + 1];
        while (!atual.folha) atual = atual.filhos[0];
        return atual.chaves[0];
    }

    private void fundir(NoB no, int indice) {
        NoB filho = no.filhos[indice];
        NoB irmao = no.filhos[indice + 1];

        filho.chaves[grauMinimo - 1] = no.chaves[indice];
        for (int i = 0; i < irmao.numChaves; i++) filho.chaves[grauMinimo + i] = irmao.chaves[i];
        if (!filho.folha) for (int i = 0; i <= irmao.numChaves; i++) filho.filhos[grauMinimo + i] = irmao.filhos[i];

        for (int i = indice + 1; i < no.numChaves; i++) no.chaves[i - 1] = no.chaves[i];
        for (int i = indice + 2; i <= no.numChaves; i++) no.filhos[i - 1] = no.filhos[i];

        filho.numChaves += irmao.numChaves + 1;
        no.numChaves--;
    }

    public int buscar(int k) {
        if (raiz == null) return -1;
        return raiz.buscar(k);
    }

    //  INTERFACE GRÁFICA 
    public void exibirGrafico() {
        if (raiz == null) {
            JOptionPane.showMessageDialog(null, "Árvore vazia!");
            return;
        }

        JFrame frame = new JFrame("Árvore B");
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        frame.setSize(1000, 600);
        frame.add(new PainelArvore(raiz));
        frame.setVisible(true);
    }

    class PainelArvore extends JPanel {
        NoB raiz;
        int larguraNo = 40;
        int alturaNo = 30;
        int gapX = 40;
        int gapY = 50;

        public PainelArvore(NoB raiz) { this.raiz = raiz; }

        public void paintComponent(Graphics g) {
            super.paintComponent(g);
            desenharNo(g, raiz, getWidth() / 2, 30, getWidth() / 4);
        }

        private void desenharNo(Graphics g, NoB no, int x, int y, int gap) {
            if (no == null) return;

            int w = no.numChaves * larguraNo;
            for (int i = 0; i < no.numChaves; i++) {
                if (no.chaves[i] == chaveBuscada) g.setColor(Color.ORANGE);
                else g.setColor(Color.CYAN);
                g.fillRect(x - w / 2 + i * larguraNo, y, larguraNo, alturaNo);
                g.setColor(Color.BLACK);
                g.drawRect(x - w / 2 + i * larguraNo, y, larguraNo, alturaNo);
                g.drawString(String.valueOf(no.chaves[i]), x - w / 2 + i * larguraNo + 12, y + 20);
            }

            if (!no.folha) {
                int startX = x - gap * (no.numChaves) / 2;
                for (int i = 0; i <= no.numChaves; i++) {
                    int childX = startX + i * gap;
                    int childY = y + alturaNo + gapY;
                    g.setColor(Color.BLACK);
                    g.drawLine(x, y + alturaNo, childX, childY);
                    desenharNo(g, no.filhos[i], childX, childY, gap / 2);
                }
            }
        }
    }

    //  MAIN - INTERFACE
public static void main(String[] args) {
    String grauStr = JOptionPane.showInputDialog("Digite o grau mínimo da Árvore B (t):");
    int t = Integer.parseInt(grauStr);
    ArvoreB arvore = new ArvoreB(t);

    String[] opcoes = {"Inserir chave", "Remover chave", "Buscar chave", "Exibir árvore gráfica", "Sair"};
    int escolha;
    do {
        escolha = JOptionPane.showOptionDialog(null, "Escolha uma operação:",
                "Árvore B", JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE,
                null, opcoes, opcoes[0]);

        switch (escolha) {
            case 0: {
                String chave = JOptionPane.showInputDialog("Digite a chave:");
                arvore.inserir(Integer.parseInt(chave));
                break; // Adicione este break
            }
            case 1: {
                String chave = JOptionPane.showInputDialog("Digite a chave:");
                arvore.remover(Integer.parseInt(chave));
                break; // Adicione este break
            }
            case 2: {
                String chave = JOptionPane.showInputDialog("Digite a chave para buscar:");
                int valor = Integer.parseInt(chave);
                arvore.chaveBuscada = valor;
                arvore.exibirGrafico();
                int res = arvore.buscar(valor);
                JOptionPane.showMessageDialog(null, (res != -1) ? "Chave encontrada!" : "Chave não encontrada!");
                arvore.chaveBuscada = -1;
                break; // Adicione este break
            }
            case 3:
                arvore.exibirGrafico();
                break; // Adicione este break
        }
    } while (escolha != 4);
    }
}
